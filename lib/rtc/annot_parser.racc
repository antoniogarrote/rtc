# ######################################################################
#
# DRuby annotation language parser
# Adapted directly from DRuby source file typeAnnotationParser.mly
# Version of GitHub DRuby repo commit 0cda0264851bcdf6b301c3d7f564e9a3ee220e435
#
# ######################################################################

class TypeAnnotationParser
  prechigh
    left T_COMMA
    right T_RARROW
    left K_OR
  preclow

  start entry

token T_EOF
token K_CLASS K_METACLASS K_MODULE K_INTERFACE K_TYPE K_TYPEVAR
token K_ALIAS K_REQUIRE K_END
token K_OR K_SELF

token T_BEGIN_LINE T_SEMICOLON
token T_COLON T_DOUBLE_COLON T_DOT
token T_STAR T_QUESTION
token T_CARROT T_BANG
token T_EQUAL

token T_RARROW
token T_LPAREN T_RPAREN
token T_LESS T_GREATER T_COMMA
token T_LBRACKET T_RBRACKET
token T_LBRACE T_RBRACE

token T_SUBTYPE

token T_STRING
token T_IVAR T_CVAR T_GVAR
token T_CONST_ID
token T_TYPE_ID
token T_SYMBOL
# token T_METHOD_NAME
token T_LOCAL_ID T_TICKED_ID T_SUFFIXED_ID T_SCOPED_ID
token T_DOUBLE_HASH

rule

  entry:
      e_method { result = val[0] }
    | e_field { result = val[0] }
    | e_class  { result = val[0] }
    | e_annotation { result = val[0] }


  field_sig:
      T_IVAR T_COLON type_expr {
        result = handle_var(:ivar, val[0], val[2]) }
    | T_CVAR T_COLON type_expr {
        result = handle_var(:cvar, val[0], val[2]) }
    | T_GVAR T_COLON type_expr {
        result = handle_var(:gvar, val[0], val[2]) }

/* entry points, presumably for non-IF annotations */

/* NOTE:  none of these actually register the types -- that has to be
   done at a higher level (where the use for the signature will be known) */

  e_method:
      method_annotation_list T_EOF { result = val[0] }

  e_field:
      field_annotation_list T_EOF { result = val[0] }

  e_class:
      class_annotation T_EOF { result = val[0] }

  e_annotation:
  	  T_DOUBLE_HASH type_ident T_LESS type_expr_comma_list T_GREATER {
  	  	result = Rtc::Types::ParameterizedType.new(handle_type_ident(val[1], val[3])
  	  }
  	  
  method_start:
      T_BEGIN_LINE { result = nil }
    | { result = nil }

  method_annotation_list:
      method_start const_method_type { result = [val[1]] }
    | method_start const_method_type method_annotation_list {
        result = [val[1]] + val[2]
      }

  field_start:
      T_BEGIN_LINE { result = nil }
    | { result = nil }

  field_annotation_list:
      field_start field_sig { result = [val[1]] }
    | field_start field_sig field_annotation_list { result = [val[1]] + val[2] }


  method_type:
  	method_name T_LESS type_id_list T_GREATER T_COLON method_sig
      { result = handle_mtype(val[0], val[2], val[6]) }
    | method_name T_COLON method_sig 
      { result = handle_mtype(val[0], nil, val[2]) }


  const_method_type:
      method_name T_LESS type_id_list T_GREATER T_COLON method_sig
      { result = handle_mtype(val[0], val[2], val[6]) }
    | method_name T_COLON method_sig 
      { result = handle_mtype(val[0], nil, val[2]) }
    | T_CONST_ID T_LESS type_id_list T_GREATER T_COLON method_sig
      { result = handle_mtype(val[0], val[2], val[6]) }
    | T_CONST_ID T_COLON method_sig
      { result = handle_mtype(val[0], nil, val[2]) }
    | method_sig {
       result = handle_mtype("__rtc_next_method", nil, val[0])
      }

  relative_method_name:
      T_STRING         
      { result = MethodIdentifier.new(val[0]) }
    | T_LOCAL_ID
      { result = MethodIdentifier.new(val[0]) }
    | T_SUFFIXED_ID    
      { result = MethodIdentifier.new(val[0]) }
    | T_SCOPED_ID
      {
      	#FIXME(jtoman): this is broken
        result = handle_scoped_id(val[0]) 
      }

  method_name:
      relative_method_name { result = val[0] }

  method_sig:
      T_LPAREN T_RPAREN block T_RARROW type_expr {
        result = construct_msig([], val[2], val[4])
      }
    | T_LPAREN type_expr_comma_list T_RPAREN block T_RARROW /*named_*/ type_expr {
        result = construct_msig(val[1], val[3], val[5])
      }
  

  block:
      { result = nil }
    | T_LBRACE method_sig T_RBRACE { result = handle_btype(val[1]) }

  type_id_list:
      type_var { result = [val[0]] }
    | type_var T_COMMA type_id_list { result = [val[0]] + val[2] }

  simple_type_var:
      T_LOCAL_ID { result = handle_type_param(:id, val[0]) }  
    | K_SELF { result = handle_type_param(:self, val[0]) }

  type_var:
      simple_type_var { result = val[0] }
    | T_CARROT simple_type_var {
        result = handle_type_param(:varargs, val[1]) }

   
   type_ident_list:
   	  T_CONST_ID { result = [val[0]] }
   	| T_CONST_ID T_DOUBLE_COLON type_ident_list { 
      result = [val[0]] + val[2]
      } 
   
   type_ident:
   	  T_DOUBLE_COLON type_ident_list {
   	  	result = {
   	  		:type => :absolute,
   	  		:name_list => val[1]
   	  	}
   	  }
   	| type_ident_list {
        result = {
        	:type => :relative,
        	:name_list => val[0]
        }
   	  }
  type_expr:
      or_type_list {
        list = val[0][:or_list]
        if(list.length > 1)
          result = Rtc::Types::UnionType.new(list)
        else
          # flatten if there is no union
          result = list[0]
        end
      }

  or_type_list:
      single_type_expr { result = {:or_list => [val[0]]} }
    | single_type_expr K_OR or_type_list {
        # need to differientiate OR lists from tuples (which are just arrays)
        val[2][:or_list] = [val[0]] + val[2][:or_list]
        result = val[2]
      }

  single_type_expr:
      type_var { result = val[0] }
    | T_SYMBOL {
    	result = Rtc::Types::SymbolType.new(eval(val[0]))
      }
    | type_ident {
        result = handle_type_ident(val[0])
      }
    | tuple { result = val[0] } /* tuples are just arrays */
    | T_DOT T_QUESTION { 
        result = Rtc::Types::TopType.instance
      }
    | T_QUESTION single_type_expr { 
        result = Rtc::Types::OptionalArg.new(val[1])
      }
    | T_STAR single_type_expr { 
        result = Rtc::Types::Vararg.new(val[1])
      }
    | T_LBRACKET field_or_method_list T_RBRACKET {
        result = handle_structural_type(val[1])
      }
    | type_ident T_LESS type_expr_comma_list T_GREATER {
        nominal = handle_type_ident(val[0])
        result = Rtc::Types::ParameterizedType.new(nominal, val[2])
      }

  tuple:
      T_LPAREN type_expr_comma_list T_RPAREN { result = val[1] }

  type_expr_comma_list:
      type_expr { result = [val[0]] }
    | type_expr T_COMMA type_expr_comma_list {
        result = [val[0]] + val[2] }


  class_decl:
      type_ident T_LESS type_id_list T_GREATER {
        id = val[0]
        type_vars = val[2]
        result = handle_class_decl(id, type_vars)
      }
    | type_ident {
        id = val[0]
        result = handle_class_decl(id)
      }

  class_annotation:
      K_CLASS class_decl {
        result = val[1]
      }
    | K_MODULE class_decl {
        result = val[1]
      }


  field_type:
      T_IVAR T_COLON type_expr {
        result = handle_var(:ivar, val[0], val[2])
      }

  field_or_method_nonempty_list:
      field_type  {
        result = {:fields => [val[0]], :methods => []}       }
    | method_type {
        result = {:fields => [],       :methods => [val[0]]} }
    | field_type T_COMMA field_or_method_nonempty_list {
        field_method_hash = val[2]
        field_method_hash[:fields] += [val[0]]
        result = field_method_hash
      }
    | method_type T_COMMA field_or_method_nonempty_list {
        field_method_hash = val[2]
        field_method_hash[:methods] += [val[0]]
        result = field_method_hash
      }

  field_or_method_list:
      { result = {:fields => [], :methods => []} }
    | field_or_method_nonempty_list { result = val[0] } 

end

---- header ----

require 'rtc/annot_lexer.rex'
require 'rtc/parser'
require 'rtc/typing/types.rb'

module Rtc

  class TypeAnnotationParser < Racc::Parser

    attr_accessor :pos, :proxy

    # FIXME(rwsims): it's not clear what proxy is for, it's used when defining
    # class constants for doing class type signatures.
    def initialize(proxy)
        @proxy = proxy
    end

    def strip_quotes(arg)
      arg.strip.gsub(/^\"/, "").gsub(/\"$/, "")
    end

    # ####################
    # helper methods for type constructors from ML parser
    # ####################

    
    def pragma(key)
      fail "Unknown pragma keyword: #{key}" if(key !="FIXME")
    end

  end

---- inner ----

---- footer ----

end
